Perfect 👍 Since you’re a beginner, I’ll explain this with a **call stack diagram** step by step.
(Think of the call stack like a pile of plates: each function call adds a plate on top, and when it finishes, that plate is removed.)

---

### Example: `fact(4)`

#### Step 1: Start

We call `fact(4)` from `main`.
👉 Stack looks like this:

```
main()
 └── fact(4)
```

---

#### Step 2: `fact(4)` needs `fact(3)`

It doesn’t hit base case (`n != 0`), so it calls `fact(3)`:

```
main()
 └── fact(4)
       └── fact(3)
```

---

#### Step 3: `fact(3)` calls `fact(2)`

```
main()
 └── fact(4)
       └── fact(3)
             └── fact(2)
```

---

#### Step 4: `fact(2)` calls `fact(1)`

```
main()
 └── fact(4)
       └── fact(3)
             └── fact(2)
                   └── fact(1)
```

---

#### Step 5: `fact(1)` calls `fact(0)`

```
main()
 └── fact(4)
       └── fact(3)
             └── fact(2)
                   └── fact(1)
                         └── fact(0)
```

---

#### Step 6: Base case hit 🎉

At `fact(0)`, the `if (n == 0)` condition is true → returns `1`.
👉 Now no more new calls are made.

The stack starts **unwinding** (removing plates one by one while returning results).

---

### Unwinding (returning values)

1. `fact(0)` returns `1` → removed from stack.
2. `fact(1)` gets `1` → returns `1 * 1 = 1`.
3. `fact(2)` gets `1` → returns `2 * 1 = 2`.
4. `fact(3)` gets `2` → returns `3 * 2 = 6`.
5. `fact(4)` gets `6` → returns `4 * 6 = 24`.
6. `main()` prints `24`.

Finally, the stack is empty → **program ends**.

---

### Visualization of unwinding

```
fact(0) → 1
fact(1) → 1 * 1 = 1
fact(2) → 2 * 1 = 2
fact(3) → 3 * 2 = 6
fact(4) → 4 * 6 = 24
```

---

✅ So execution **stops** naturally because:

1. Base case prevents infinite calls.
2. Stack unwinds until nothing is left to run.

---

Would you like me to draw this as a **flow diagram (like a tree)** so you can visualize calls branching down and then returning up?
